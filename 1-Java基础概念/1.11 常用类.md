## 1. BigInteger 和 BigDecimal 两个类
---
>针对超大型整数进行赋值和操作的类

### BigInteger
```Java
BigInteger b1 = new BigInteger("12345678901234567890");  
BigInteger b2 = new BigInteger("10000000000000000000");  
  
BigInteger b3 = b1.add(b2);  
System.out.println(b3);
```

### BigDecimal

`RoundingMode.CEILING` 除法进位
`RoundingMode.HALF_UP` 四舍五入
`RoundingMode.FLOOR` 去尾法
## 2. 包装类
---
>将基本数据类型包装成引用数据类型

| 基本数据类型 | 引用数据类型  |
| ------ | ------- |
| short  | Short   |
| int    | Integer |
|        |         |

### 装箱

```Java
//装箱  
Integer j = Integer.valueOf(i);  
System.out.println(j);
```

### 拆箱
```Java
//拆箱  
int k = j.intValue();  
System.out.println(k);
```
## 3. 集合类（重要）
---
>用于保存多个数据
>集合中只能保存应用引用类型的数据

- 用于保存多个数据
- 与数组比较的区别
- **数组**：同类型数据，定长，在内存中连续（数据结构）
- **集合**：<font color="#2DC26B">不同数据类型（通常是相同的），不限制数据数量，不同的集合类有不同的数据结构</font>

>**==实际开发中：基本上使用集合，告别数组==**

- 与数组最大的区别是"长度"定义
	- **数组的长度**：数组能存储的最大数量
	- **集合的长度**：集合中当前已经存储的数据数量，长度是自动维护的

	数组可以定义任何数据类型，基本数据类型，引用数据类型
	**集合只能存储引用数据类型，基本数据类型需要使用包装类**


**线性集合**：Collection 接口，有两个重要子接口：List 和 Set
- 线性结构来源于数据结构中线性结构
	- 线性结构：一个数据节点只保存一个数据，同时该节点最多只能同时有一个前驱和一个后继
	- 典型：数组，链表

**键值对结构**：本质上仍然是线性结构
- 一个数据节点由 Key（键）和 Value（值）两个部分组成
	- Key 可以理解为可自定义的下标
	- 所有数据节点的 Key 不能重复，Value 可以重复


| Key   | a   | b   | c   | d   | e   |
| ----- | --- | --- | --- | --- | --- |
| Value | 31  | 22  | 16  | 78  | 86  |

### (1) 线性集合 - List (常用)

有序（号）可重复集合
List 集合下
重复的标准：两个数据 equals 相等，认为两个数据重复

**常用实现类**
- Array

```Java
//1.声明一个集合  
//<> 泛型：约束集合中数据的类型  
List<Integer> list = new ArrayList<Integer>();  

//2.向集合中添加数据  
list.add(22);  
list.add(453);  
list.add(14);  
list.add(131);  
list.add(22);   //允许重复  
System.out.println(list);  

//（2）在集合的特定位置插入一个数据，数据会自动移动  
list.add(2, 20); //在下标2的地方插入数据20，元位置及后方数据自动后移  
System.out.println(list);  

// 3.修改集合特定位置的数据  
list.set(2, 30);  
System.out.println(list);  

// 4.移除特定位置的数据  
list.remove(2);  
System.out.println(list);  

// (2)移除具体的数据  
list.remove(Integer.valueOf(22));   //可以将其包装为包装类使用  
System.out.println(list);  

//（3）清空集合  
//        list.clear();  
//        System.out.println(list);  

//5.检索  
//（1）集合中是否包含某个数据  
boolean b1 = list.contains(15);  
boolean b2 = list.contains(22);  

//（2）返回集合中的数据的位置  
int i1 = list.indexOf(17);  
int i2 = list.indexOf(22);  
int i3 = list.lastIndexOf(22);  
System.out.println(i1); //无法找到  
System.out.println(i2);  
System.out.println(i3);  

//（3）集合中数据的数量（集合的长度），数据数量在插入数据和删除数据时自动维护  
int len = list.size();  

//6.集合的便利  
//(1)利用下标遍历集合  
for (int i = 0; i < list.size(); i++) {  
	//list.get(i);  
	System.out.println(i);  
}  

//(2)for-each循环  
for (int num : list) {  
	System.out.println(num);  
}  

//（3）迭代器模式  
Iterator<Integer> ite = list.iterator();    //取得集合实例对应的迭代器实例  

//进行迭代  
while (ite.hasNext()) {  
	int num = ite.next();  
	System.out.println(num);  
}
```

```Java
public static void main(String[] args) {  
    //1.声明一个集合  
    //<> 泛型：约束集合中数据的类型  
    List<Integer> list = new ArrayList<Integer>();  
  
    //2.向集合中添加数据  
    list.add(22);  
    list.add(453);  
    list.add(14);  
    list.add(131);  
    list.add(22);   //允许重复  
    System.out.println(list);  
  
    //1.自然排序  
    Collections.sort(list);  
  
    //2.倒序  
    Collections.reverse(list);  
  
    //  升序 + 倒序 = 降序  
  
    //3.随机打乱集合  
    Collections.shuffle(list);  
  
    //4.获取集合中最大值和最小是  
    int max = Collections.max(list);  
    int min = Collections.min(list);  
}
```
### (2) 线性集合 - Set

**无序（号）不重复**
- Set 集合中不允许利用下标操作集合中数据，重复数据只保留一个
	- 集合中数据存放的位置不由开发者决定，而是由集合实现类的底层算法决定

**底层算法**
- **HashSet**
	- 底层算法是基于存入实例的 hashcode 大小
	- 按照数据实例的哈希码，按照哈希码顺序存放数据
- **TreeSet**
	- 底层算法是基于二叉排序树（红黑树）实现的
	- 按照数据实例的自然大小
- **LinkedHashSet**
### (3) 键值对集合 - Map

