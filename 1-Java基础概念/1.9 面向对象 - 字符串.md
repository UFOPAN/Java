## 1. 实例的五个操作

---

### 1.1 业务逻辑的相等

默认的 `equals` 方法等同于 `==`
==重写 Object 类的 equal 方法，实现逻辑需求==

### 1.2 实例转字符串

需要将实例

### 1.3 实例的哈希码

哈希码：是由真实物理地址经过计算得到的一个整数，通常以十六进制方式实现
同一块内存，无论经过多少次计算，它的哈希码不变
不同对象指向同一个实例，可以得到同一个哈希码

==哈希码是由 Object 类的 hashcode () 计算得到的==
也可以自己重写 hashcode () 方法，来计算哈希码（最好不要）

```java
public int hashCode(){
	//可以利用类的所有属性的值来生成hashcode（哈希码）
	//业务类开发，很少涉及重写哈希码
	return Object.hash(sno,sname);
}
```

### 1.4 实例的克隆

直接调用继承自 Object 类的 clone 方法，该克隆方法是保护权限的

1. 子类重写 clone 方法，提升访问权限为 public
2. 子类实现 Cloneable 接口，表示自己可以被克隆

### 1.5 实例的可比较（重要）

1. 实现 Compareable 接口
2. 实现其中的 compareTo 方法来设置实例之间的大小规则

实例有了大小规则，就可以利用内置的 API 方法实现排序，找机制的方法

## 2. 异常机制

---

> 程序在编译或运行期间，因为某些意外情况造成的程序中断

Java 看待异常问题：程序在执行期间发生异常是一件正常的事情

- 管理异常和控制异常
- 当异常真正发生时，会在发生异常的位置上立刻产生一个异常类型的 e
- 对这个实例 e 进行操作来管理

### 2.1 异常类的继承体系
Throwable 类
- Error 类（错误类）它的子类以 Error 为后缀
	- StackOverflow
>错误类：通常情况下，分析代码逻辑没有问题，大概率是硬件问题，硬件问题无法通过软件手段进行修复

- ==Expection==类（异常类）它的子类以 Expection 为后缀
	- RuntimeException（运行时异常）
		- NullPointerException（空指针异常）
		- ArrayIndexOutOfBoundsException
		- ...
	- IOException（读写异常）

### 2.2 运行时异常和检查性异常的区别（重要）

**RuntimeException** - ==运行时异常==
编译时不会强制要求开发者给出异常发生时的处理预案
- <font color="#2DC26B">运行时异常完全可以避免，主要发生原因就是逻辑不严谨</font>

**Exception 及它的其他子类** - ==检查性异常==
编译时强制要求开发者给出异常发生时的处理预案
- <font color="#2DC26B">检查性异常通常是由意外原因造成的</font>

### 2.3 异常的处理方式 -- 上报异常（抛出异常）
><font color="#2DC26B">在异常发生处，不进行处理，将异常实例抛出给方法调用者，由调用者决定如何继续处理</font>

==调用者需要处理抛出的异常==：
如果最后 main 方法也没有处理异常，异常被抛出给 JVM，异常相当于无人处理
当异常实际发生时，程序崩溃

通过在方法上利用 `throws` 声明该方法会抛出哪些异常（可以多个）
调用者调用方法时，需要处理这些异常

==人为制造异常==：人为触发一个必定触发的异常
`throw` 一个异常的实例

```Java
exception e = new Exception();	//创建一个异常类型的实例
throw e;	//该句代码一定会发生一个Exception类型的异常
```

### 2.4 异常的处理方式 -- 捕获异常（处理异常）

try... catch... finally...
try 块是必须的，catch 和 finally 至少有一个，catch 有多个

try... catch... (catch 可以多个) 
try... finally... (使用较少)
try... catch... finally... (catch 可以多个)

```Java
try{	//正常的执行程序
...
}catch(... e){	//对异常的处理预案
...
{catch(Exception e){	//捕获所有类型的异常，只能放在最后面
...
}final{	//进行资源回收等收尾工作
...
}
```

- 无论如何 final 都会执行，如果 try 中有 return 语句，会把 final 块插到 return 之前执行
- 捕获范围大的异常应该放在下面（捕获父类异常）
![[../-附件-/1.附件/异常捕获.png]]
## 3. 字符串类型

---
### 3.1 字符串常量类 String

String 类型的数据在重新赋值时，不是在内存中修改数据，而是重新新建内存，将新内存地址赋值给变量（每次都改变变量的内存指向），所以 String 又被称为字符串常量
![[../-附件-/1.附件/String的内存模型.png]]
### 3.2 字符串变量类 StringBuffer 与 StringBuilder

专门进行字符串拼接操作，效率相对较高
两个类几乎一样

==StringBuffer== 是线程安全的，性能比 StringBuilder 慢一些（但几乎可以忽略）
StringBuilder 是线程不安全的

### 3.3 String 类型常用 API

1\. 得到各个字符组成的 char 数组
`str.toCharArray()`
```Java
//1.得到各个字符组成的char数组
char[] cs = str.toCharArray();   
System.out.println(Arrays.toString(cs));
```

2\. 取个字符串某个位置上的字符
`str.charAt(0)`
```Java
//2. 取得字符串某个位置上的字符
char c = str.charAt(0);  //取得第一个字符
System.out.println(c);
```

3\. 将一个字符数组拼装成字符串
`String x = new String(xs)`
```Java
char[] xs = {'I','L','i','k','e'};
String x = new String(xs);
System.out.println(x);
```

4\. 得到字符串的长度
`str.length()`

5\. 判断某个字符串在数组中是否存在
`str.contains()`

6\. 判断某个字符串是否以某个前缀开头
`str.startWith()`

7\. 判断某个字符串是否以某个后缀结尾
`str.endWith()`

8\. 判断某个字符串在字符串中第一次出现的位置，==如果没有返回-1==
`str.indexOf()`

9\. 判断某个字符串在字符串中最后一次出现的位置，==如果没有返回-1==
`str.lastIndexOf()`

10\. 判断某个字符串在字符串中某个位置起，第一次出现的位置
`str.indexOf("ABC",5)`

11\. 字符串的比较
`s1.equal(s2)` 用于 String 对象与 String 实例比较
`s1.equalsIgnoreCase(s2)` 忽略大小写比较

12\. 截取字符串
`subString(x,y)` 截取字符串\[x, y) 的位置的内容
`subString(x)` 截取字符串 3 到结尾的内容

13\. 分割字符串
`str.spilt(",")` 以英文 `,` 为分隔符，将字符串分割成字符串数组

14\. 替换字符串
`str.replaceAll("ABC","***")`

15\. 去掉字符串两端多余的空格
`str.trim()`

16\. 字符串的空判断
`str.isEmpty`
```Java
str.isEmpty();

if(s10 == null || s10.isEmpty()){	//不能颠倒顺序
	System.out.println("s10没有输出内容")
}
```

---
## 练习
### 练习一
在控制台上输入一个 Email 的地址

	xiaoming123@xxx.com

利用 String 的 API 判断 Email 地址是否合法
合法规则
1. 必须有且只有一个`@`
2. 必须有且仅有一个`.`
3. @不能是第一个字符，`.` 不能是最后一个字符
4. @必须在 `.` 之前，且两者之间有其他内容

### 练习二
设计一个方法，传入两个字符串类型的参数 a 和 b
返回整数类型的数据：  b 在 a 中出现的次数
a：abcdabcaba
b:  ab                  ab 出现了 3 次
返回：3

### 练习三
定义一个内容全部是小写英文字母的字符串，内容长度任意
alkdjfoiwujkdjlaflanvlkzkahfkjiweroi
在控制台上打印字符串中各个小写字母的出现次数
>提示：可以定义一个长度是 26 的整数数组记录各个字母的次数
