## 什么是多态
---
>一类事物在不同情况下的不同形态

## 1.引用数据类型的类型转换
---
>必须发生在有继承关系的两个类中

1. **上溯造型**
	1. 子类的实例可以自动转换成父类的对象
	2. 用父类声明，使用子类进行实例化
	3. ==现实意义==：将一个特殊的子类个体，看作一个普通的父类个体
		-  强调该个体的普遍性，忽视该个体的特殊性
	4. ==代码意义==：只能调用父类的特征

```java
Shape s1 = new Circle();    //上溯造型：使用父类来声明，使用子类进行实例化
s1.color = "黑色";    //只能访问作为图形的特征
```


2. **下溯造型**
	1. 一个父类的对象，需要通过强制转换才能变成子类的对象
	2. ==下溯造型成功的前提==：该父类指向的对象，是由该子类上溯造型得到（先上溯，再下溯）
		- 从实例角度看
			1. 父类的实例 -> 子类的对象（×）
			2. 子类a的实例 -> 父类的对象 -> 子类a的实例（√）
			3. 子类a的实例 -> 父类的对象 -> 子类b的实例（×）

```java
public static void show(Shape s){
	if(s instanceof Rectangle){    //检查了类型是矩形
		//传入的是矩形实例
		//将s下溯回矩形
		Rectangle r = (Rectangle) s;   //并没有完全解决代码重写多次的问题
		...
	}else if(s instanceof Circle){
		...
	}else if(s instanceof Triangle){
		...
	}
}

publie static void main(String[] args){
	Rectangle r = new Rectangle("绿色",4,4)
	Circle c = new Circle(...)
	Triangle t = new Triangle(...)
	
	show(r);    //隐蔽的上溯造型
	show(c);
	show(t);

}
```

## 2.方法的重写（Override，运行时多态）
---
>子类从父类继承来的方法进行重新实现

- 使用`@Override`标注重写的部分

1. ==现实意义==：子类与父类在同一个行为上，有不同的表现形式
2. ==重写方式==：子类与父类同名
	1. 同名，同参数类型，同返回类型
	2. 子类与父类的权限
3. ==重写调用==：优先调用子类重写后的方法
	1. `new`那个类的实例，优先调用哪个类的

```java
public static void show(Shape s){
	System.out.println("图形的周长为"+s.getRound());
	System.out.println("图形的面积为"+s.getArea());
}
```
## 3.多态的设计和实现
---
- **==开闭原则==**：对扩展开放，对修改关闭

- **==多态的设计==**
	1. 存在继承体系
	2. 父类抽取共性的方法，进行定义
		1. 子类重写共性方法，进行实现
	3. 多态方法的形参是以父类的类型声明的（传参时的形成的上溯造型）
	4. 多态方法的内部通过调用重写方法，实现开闭原则

- 保证了多态方法可以适配任意子类，而不用修改自身

---
## 4.抽象关键字
---
>abstract

1. 编写多态设计时，面临的三个问题
	1. 问题1：对子类共性进行抽象时，得到的父类是概念性的，无实物
		 - [ ] 从编程角度讲，不应该创建父类实例
	2. 问题2：父类中多态方法大部分情况下应该只是给出定义，无法给出代码实现，但当前语法上必须要求给出代码实现
	3. 问题3：编写子类时，没有强制要求重写父类的方法

1. **抽象类**：abstract class
	1. ==特点：抽象类不能实例化==

1. **抽象方法**：abstract修饰方法
	1. 使用抽象关键字修饰方法：抽象方法
		1. 特点：没有方法体（不用写()）
			1. 只需给出方法声明（方法定义）即可，不需给出具体细节
			2. ==抽象方法只能存在于抽象类中==
			3. 变成抽象方法，只给出声明，不用实现
		2. ==子类继承抽象父类后，必须“实现”（强制重写）父类中所有的抽象方法==

1. 抽象关键字应该使用在父类中，用于描述一个无法精确描述的父类概念（抽象类），用于描述一个无法精确描述的行为（抽象方法）
2. 抽象方法只能出现在抽象类中，抽象类中可以包含抽象方法和常规方法

## 5.接口 interface
---

- 接口(interface)不是类
	- 编码意义：它是对Java单继承的不足进行补充
	- 现实意义：具备某种能力的事物，官方推荐的命名XXXXable，其中XXXX是动词

- 一个类只能有一个直接的父类，但是可以同时实现多个接口
- 接口中只能定义抽象方法，常量和lambda表达式

接口中的抽象方法是
在接口里，`public abstract`是可以省略的
`implements`引入接口，使用逗号分隔
从使用角度来说，接口可以理解成一种简化版的抽象类

## 练习

### **练习一**

高速收费站的显示系统

车的类型：轿车，客车，卡车，未来不排除有新的车类型
- *收费标准*：
	- 轿车：10元
	- 客车：载客人数不高于25的收费30元，高于25收费50元
	- 卡车：载重量不高于50的收费80元，高于50的收费150元
- 设计一个多态方法，支持任意车辆实例，显示该实例应缴费金额

- *main方法测试*
	- 一个轿车实例
	- 一个载客人数20人的客车
	- 一个载客人数30人的客车
	- 一个载重35的卡车
	- 一个载重55的卡车

---
### 练习二

设计一个POS机收款的功能，接受银行卡
根据输入的消费金额，在相应的银行卡中进行消费


银行卡有以下两个种类
1. 储蓄卡
	- 卡片预先存了钱，才能消费
1. 信用卡
	- 授信额度：允许最多欠的钱数
	- 使用额度：已经欠的钱数


main(){

	 创建一张余额是6000的储蓄卡A
	 创建一张授信额度是5000的信用卡B，当前使用额度是0

	 使用A消费4000元
	 使用B消费4000元
	 再次使用A消费3000元
	 再次使用B消费3000元

}