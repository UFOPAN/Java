## 1. 多线程的相关概念
---
**进程**：计算机支持多任务的一种手段，一个程序在内存中以进程的方式被 CPU 调用
- 一个单核 CPU，在单位时钟内，只能运行一个进程
	- *轮转时间片*：时间片是一个很小的时间单位，多个进程去抢占时间片
	- 宏观上看起来是多个进程在同时进行
	- 微观上单核 CPU 在一次时间片内只能执行一个进程，实际上是串行执行
- *一个进程（应用程序）内*：可能有多个并行执行的程序，这样的程序就是**线程**

**线程的作用**：处理程序内的并行任务（同时执行的代码）

## 2. 线程的生命周期
---
![[../-附件-/1.附件/线程的生命周期.png]]

## 3. Java 中实现线程的方式
---

### 编写一个类，继承 Thread 类，重写 run 方法，在 run 方法中编写线程代码
>Thread 类本身就已经实现了 Runnable 接口
- 启动线程，直接使用 start 方法，启动线程
### 编写一个类，实现 Runnable 接口，重写 run 方法，在 run 方法中编写线程代码

- 通过 Runnable 接口方式实现的线程，需要挂载到 Thread 类的实例中执行
```Java
Thread t1 = new Thread(m1);
t1.start;
```
- 匿名方式启动
```Java
new Thread(m2).start();
```
- 临时线程

## 4. 线程安全
---
1\. 线程安全方法 `synchronized`
在一个方法上通过 `synchronized` 关键字
==设置到资源类中==

2\. 资源加锁 `同步代码块`
通过同步代码块
```Java
synchronized(锁定的资源){
	某个线程对资源操作的操作具有排他性
	只有这个线程做完之后
}
```
保证一段代码必须某一个线程全部执行完毕后，其他线程才可以执行
## Socket 变成（网络编程）
---
Socket 套接字：基于 TCP/IP 协议的网络通信的 API
特点：请求-应答方式

- 客户端发起网络请求给服务器  
	- 客户端 -> 服务器请求
- 服务器对请求进行应答 
	- 客户端 <- 服务器应答

>请求与应答都是成对出现的，不允许连续两次请求或者连续两次应答

### 1 . 服务端 API
`ServerSocket 类`：开放服务端的端口，用于监听客户端请求
监听到客户端请求后，创建套接字与客户端进行连接
一个服务端监听也可以同时创建多个客户端的通信
处理每个客户端的通信都需要借助线程

`Socket类 `: 负责服务端与客户端的通信

### 2 . 套接字 API
Socket 类：负责客户端与服务端的通信
 
服务端程序和客户端程序可以部署在不同的计算机中

---
`StartServer.java`

```Java
package com.neusoft.server;  
  
import java.net.ServerSocket;  
import java.net.Socket;  
  
public class StartServer {  
  
    public static void main(String[] args) throws Exception {  
       //1. 创建服务器监听，用于监听客户端的请求  
       // 需要开放服务器计算机的一个端口(1 - 65535,个人程序不建议使用20000以下的)  
       // 案例中使用了40001端口  
       // 其他计算机通过服务器IP和端口来连接  
       ServerSocket ss = new ServerSocket(40001);  
       while(true) {  
          //2. 服务器监听到了客户端连接，创建一个Socket与客户端进行通信  
          Socket s = ss.accept();  //阻塞事件：当有客户端连接时，才继续执行，否则在该行阻塞  
          //为连接创建一个线程，进行后续的通信处理  
          UserThread t = new UserThread(s);  
          t.start();  
       }  
         
    }  
  
}
```

`UserThread.java`

```Java
package com.neusoft.server;  
  
import java.io.DataInputStream;  
import java.io.DataOutputStream;  
import java.io.IOException;  
import java.net.Socket;  
  
public class UserThread extends Thread{  
  
    private Socket s;  
      
    public UserThread(Socket s) {  
       this.s = s;  
    }  
      
    @Override  
    public void run() {  
       //获取连接输入和输出流  
       //输出流(修饰socket的原始输出流)  
       DataOutputStream dos = null;  
       //输入流（修饰socket的原始输入流）  
       DataInputStream dis = null;  
       try {  
          dos = new DataOutputStream(s.getOutputStream());  
          dis = new DataInputStream(s.getInputStream());  
       } catch (IOException e) {  
          // TODO Auto-generated catch block  
          e.printStackTrace();  
       }  
         
       while(true) {  
          try {  
             //先接收客户端发来的请求  
             String rec = dis.readUTF(); //阻塞事件：只有客户端发来消息，程序才能继续向下执行  
             String back = "";  
             //根据请求的内容给出相应的处理  
             if(rec.equalsIgnoreCase("hello")) {  
                back = "Hi!";  
             }else if(rec.equalsIgnoreCase("你好")) {  
                back = "你好";  
             }else if(rec.equalsIgnoreCase("谢谢")) {  
                back = "不客气";  
             }else {  
                back = "抱歉，我没听懂";  
             }  
               
             //再给客户端应答  
             dos.writeUTF(back);  
             dos.flush();  
          }catch(Exception e) {  
               
          }  
       }  
         
    }  
}
```

`StartClient.java`

```Java
package com.neusoft.client;  
  
import java.io.DataInputStream;  
import java.io.DataOutputStream;  
import java.net.Socket;  
import java.util.Scanner;  
  
public class StartClient {  
  
    public static void main(String[] args) throws Exception {  
       //客户端访问服务器的IP和端口  
       Socket s = new Socket("10.71.52.12", 40001);  
         
       //获取连接输入和输出流  
       //输出流(修饰socket的原始输出流)  
       DataOutputStream dos = new DataOutputStream(s.getOutputStream());  
       //输入流（修饰socket的原始输入流）  
       DataInputStream dis = new DataInputStream(s.getInputStream());  
         
       while(true) {  
          //从控制台获取要发送给服务器的消息  
          Scanner sc = new Scanner(System.in);  
          System.out.println("请输入发送给服务器的消息:");  
          String str = sc.nextLine();  
            
          //发送消息给服务器  
          dos.writeUTF(str);  
          dos.flush();  
          //立即接收服务器的应答  
          String rec = dis.readUTF();  
          System.out.println("服务器的回应是:"+rec);  
       }  
    }  
}
```

[点击查看文档](D:\BaiduNetdiskDownload\0715\项目作业)

[socket 编程](https://www.cnblogs.com/yiwangzhibujian/p/7107785.html)