## 1.封装

---

### ==类级别==（class）的封装

> 将零散的属性封装成类

-   方法的参数过多时，不利于理解
-   将其封装为一个类，通过一个对象包含所有的参数

### ==包级别==（package）的封装

> 在物理上将具备相同功能或相似代码特征的类进行隔离和分配，起到类似文件夹的作用

1. 相同的模块（业务逻辑）的代码放到一个包中
    - 物理上：一个模块使用一个 package
        - com.neusoft.base 基础
        - com.neusoft.time 时间
        - com.neusoft.salary 薪酬
    - 逻辑上：这些模块之间“==高内聚-低耦合==”
        - **低耦合**：模块之间要尽可能减少它们互相之间的依赖关系
            - 假设：薪酬模块的某个功能需要通过时间模块来实现
                - 薪酬 依赖于 时间
                - 时间 -> 薪酬
2. 相同的代码功能（技术逻辑）的放入同一个包中
    - **MVC 模式**
![[../-附件-/1.附件/MVC.png]]

3. 两者相结合
    - com.neusoft.base.view ---- 业务层面进行隔离
        - com.neusoft.base.control ---- 业务内的视图
        - ......
    - com.neusoft.time
        - com.neusoft.time.view
        - ......
4. 微服务项目
    - project 项目
        - base 项目：微服务项目 基础模块
            - com.neusoft.base.view ---- 业务内的视图
            - ......

### 访问权限修饰符

> 设置类，属性或方法的访问范围，有四种权限

| 关键字                 | 权限 | 类的内部 | 同一 package 下的子类 | 不同 package 下的子类 | 不同 package 的类 |
| ---------------------- | ---- | -------- | --------------------- | --------------------- | ----------------- |
| private                | 私有 | √        | ×                     | ×                     | ×                 |
| 无关键字（包级关键字） | 默认 | √        | √                     | ×                     | ×                 |
| protected              | 保护 | √        | √                     | √                     | ×                 |
| public                 | 公有 | √        | √                     | √                     | √                 |

修饰类：默认和公有
修饰属性和方法：四种都可以使用

Q1：一个属性被设置为 private 的目的
只允许在自己类中调用

Q2：一个类被设置为默认权限的目的
一个类只能在所在包中使用（创建实例），不能跨包使用

Q3：一个类，只设置 private 的构造方法的目的
为了限制这个类的实例数量

Q4：**一个父类中的方法，权限设置为 protected 的目的是什么**
这种方法通常是一个半成品：

1. 父类实现了一个功能的上半部分
2. 子类重写后实现这个功能的下半部分
3. ==子类的权限不能低于父类的权限（提升权限）==

> 实际工作中，常用：private 和 public

</br>

### 访问器方法（set 和 get 方法）

**JavaBean 规范**：Java 类中的属性设置成 private，通过 public 的访问器方法来进行访问

-   目的一：适配 Java 应用框架，很多框架底层只认 set 和 get 方法
-   目的二：更灵活的设置“半权限” - 通过 set 方法和 get 方法分离了读和写的权限 - 只设置某个方法时，可以将读写权限分离 - 而 public 不能分离读和写的权限
    > getter 允许读，setter 允许写

## 2.静态关键字（重要）

---

> 面向对象的实例特征（主要指属性）

**动态**：没有动态这个概念，相对与静态的概念
**静态**：静态属性的内存空间是一成不变的，至始至终只有一个内存空间

**静态属性**：所有的实例共享同一块内存空间

-   本质上与实例（个体）是无关的，与类（概念）是相关的
-   静态属性的调用应该通过类，而不是实例（个体）

**静态方法**：只能==直接==调用其他静态内容（静态方法和静态属性）

> 普通的方法可以直接访问静态内容和非静态内容
> 在字节码（class）加载到内存时，静态属性和方法就已经做好了内存准备，但是非静态属性不一定准备好了。

**触发类（字节码）加载到原空间的时机**：

-   创建了该类的实例 -- 调用了这个类的构造方法
    -   静态内容准备好了，非静态内容准备好了
-   访问了该类的静态属性或静态方法
    -   静态内容准备就绪，非静态内容没有准备就绪
-   通过反射机制 Class.forName() 手动加载类

**静态代码块**：

-   特性：参照静态方法的理解，只能访问静态内容
-   特点：在类被第一次加载到元空间时执行一次
-   做用：为静态属性，进行复杂的初始化操作

现实意义：类的某个属性属于“类”的概念，而不属于某个个体
![[../-附件-/1.附件/静态属性的理解.png]]
## 3.最终关键字 final

---

表示最终的含义：

1.修饰类
最终的类，不允许被继承，不允许有子类

2.修饰属性或变量
最终的属性或变量：不允许修改赋值，也被称为常量
通常以全大写字母命名

3.修饰方法
最终的方法：不允许被重写

问题 1：abstract 和 final 同时修饰一个类或一个方法？

-   两者不同同时使用
-   abstract：表示抽象，类需要子类，方法需要重写
-   final： 表示最终，类不能有子类，方法不能被重写
-   两者在功能上是冲突的，所以不能同时使用

问题 2：系统中在定义一个常量时，通常使用 static+final 为什么？

-   final：表示它为一个常量，不能修改赋值
-   static：内存中只有一个，不会随着实例数量增加而增加
-   可以直接通过“类名.”进行调用，无需先创建实例

## 4.设计模式 - 单例模式

---

创建型模式：用于创建实例时使用的设计模式
作用：约束一个类的实例，最多只有一个（工具箱）

Java 中支持两种写法:

1.饿汉式单例：无论唯一的实例是否使用，都立刻创建它

```java
public class HungrySingleton {

    //2. 在类的内部创建唯一的实例，饿汉式单例直接创建实例
    //3. 向外界提供一个该属性的"只读"权限
    //3.1 属性是私有权限private
    //4.属性是静态的，配合get方法使用
    //5.通过final属性，进一步明确属性的只读性质，防止内部篡改
    private static final HungrySingleton instance = new HungrySingleton();

    //1. 私有构造方法：不允许随意创建这个单例
    private HungrySingleton() {
    }

    //3.2 只提供属性的get方法，限制其只读
    //4. 方法设置成static静态，外部可以不依赖实例即可调用，通过类名直接调用
    public static HungrySingleton getInstance() {
        return instance;
    }
}
```

2.懒汉式单例：实例在第一次使用时才创建

    编写懒汉式单例
    private static HungrySingleton instance；
    一开始不着急创建实例
    在第一次调用getInstance()方法时，判断instance是否存在
    不存在再创建

```java
public class LazySingleton {  
  
    //2.在类的内部创建唯一的实例，但不是立即实例化  
    private static LazySingleton instance;  
  
    //1.私有构造方法，不允许随意创建这个实例  
    private LazySingleton() {  
    }  
  
    //3.设置唯一实例的get方法  
    //synchronized保证在多线程的情况下只能创建唯一实例  
    public static synchronized LazySingleton getInstance() {  
        if (instance == null) {  
            instance = new LazySingleton();  
        }  
        return instance;  
    }  
}
```

>java中建议使用饿汉式单例

	单例的使用：
	HungrySingleton hungrySingleton = HungrySingleton.getInstance();  
	LazySingleton lazySingleton = LazySingleton.getInstance();